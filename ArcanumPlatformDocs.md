Техническая документация для разработки платформы Arcanum (Часть 1 из 3)
Эта документация описывает архитектуру и последовательные шаги для создания гипер-кастомизируемой, AI-центричной платформы для личного развития Arcanum. Руководство предназначено для разработки с использованием Cursor AI и последующего развертывания на Vercel.

Раздел 1: Фундаментальная архитектура и технологический стек
1.1. Ключевые принципы
Платформа Arcanum строится на трех основных столпах:
Максимальная кастомизация: Каждый пользователь обладает возможностью полностью изменять свое рабочее пространство. Любой элемент интерфейса, от панелей до отдельных кнопок и виджетов, можно перемещать, изменять в размере, закреплять и удалять. Платформа имеет два режима: режим использования (статичный интерфейс) и режим редактирования (полная кастомизация).
AI-центричность: В ядре платформы находится система взаимодействующих ИИ-агентов под управлением центрального «мозга». ИИ отвечает за генерацию контента, автоматизацию задач, программирование новых элементов по запросу пользователя и адаптацию всего интерфейса.
Геймификация и вовлечение: Платформа спроектирована для создания «вау-эффекта» и удержания пользователя в состоянии потока для постоянного самосовершенствования. Это достигается через систему уровней, очков опыта (XP), наград, персонализированных визуальных эффектов и звукового сопровождения.
1.2. Архитектура ИИ-агентов
Архитектура ИИ должна быть продумана для обеспечения модульности и масштабируемости. Она будет иерархической:
Уровень 1: "Arcanum Brain" (Главный Оркестратор)
Роль: Центральный мозг всей платформы. Он получает все высокоуровневые команды от пользователя (голосовые или текстовые) и делегирует их соответствующим агентам-оркестраторам. Он хранит память о действиях пользователя и его фокусе.
Звание: Chief Orchestrator AI
Уровень 2: Специализированные Оркестраторы
Роль: Управляют группами ИИ-агентов в рамках одной функциональной области.
Звания и роли:
UI/UX Orchestrator: Отвечает за все изменения в интерфейсе. Управляет агентами, отвечающими за редизайн, анимации и кастомизацию.
Task & Resonance Orchestrator: Управляет жизненным циклом задач, их резонансом и состоянием потока пользователя.
Personalization Orchestrator: Управляет агентами, создающими персонализированный контент (арты, маскоты, тексты).
Уровень 3: Исполнительные ИИ-Агенты
Роль: Выполняют конкретные, атомарные задачи.
Звания и роли:
Layout Customization Agent: Физически применяет изменения положения и размера элементов на UI.
Button Programming Agent: По текстовому запросу пользователя создает новую кнопку и генерирует код для ее функциональности.
Task Assessor Agent: Автоматически проверяет выполненные и невыполненные задачи, обновляет опыт и применяет "наказания".
Resonating Task Agent: Анализирует все задачи из 12 сфер и генерирует одну, наиболее резонирующую и эффективную для пользователя в данный момент.
Flow State Agent: Создает "мосты" между задачами из разных сфер, чтобы поддерживать пользователя в состоянии потока.
Global Design Agent: Мгновенно изменяет дизайн всей платформы при смене фокуса на сферу или при получении нового уровня.
Mascot Generator Agent: Генерирует уникальные арты-маскоты для каждой подкатегории в сферах жизни.
Punishment Agent: Интегрирован с платежным API (для токенов OpenAI) и управляет финансовыми "ставками" на выполнение задач.
1.3. Технологический стек
Фреймворк: Next.js (React)
База данных и аутентификация: Supabase
Развертывание: Vercel
Стилизация: Tailwind CSS (для быстрой и гибкой кастомизации)
Управление состоянием: Zustand или Redux Toolkit (для сложного глобального состояния UI и данных)
Drag-and-Drop: dnd-kit (для реализации функционала перемещения элементов)
Интеграция с ИИ: OpenAI API

Раздел 2: Пошаговая настройка проекта
Шаг 1: Настройка окружения
Создайте новый проект на Vercel.
Создайте новый проект на
 Supabase.
В настройках проекта Supabase перейдите в Project Settings > API. Скопируйте Project URL и anon (public) key.
Шаг 2: Инициализация проекта Next.js
В вашем терминале выполните команду для создания нового Next.js приложения с Tailwind CSS:
Bash
npx create-next-app@latest arcanum-platform --typescript --tailwind --eslint


Шаг 3: Интеграция с Supabase
Установите клиентскую библиотеку Supabase:
Bash
npm install @supabase/supabase-js


Создайте файл .env.local в корневой папке проекта и добавьте в него ключи из Шага 1:
Фрагмент коду
NEXT_PUBLIC_SUPABASE_URL=YOUR_SUPABASE_PROJECT_URL
NEXT_PUBLIC_SUPABASE_ANON_KEY=YOUR_SUPABASE_ANON_KEY


Шаг 4: Настройка утилиты-клиента Supabase
Создайте файл lib/supabase/client.ts для создания клиентского экземпляра, который будет использоваться во всем приложении:
TypeScript
import { createBrowserClient } from '@supabase/ssr'

export function createClient() {
  return createBrowserClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!
  )
}


Шаг 5: Проектирование схемы базы данных (начальная версия)
В редакторе SQL вашего проекта Supabase выполните следующие запросы для создания базовых таблиц:
Таблица для хранения кастомных настроек интерфейса пользователя:
SQL
CREATE TABLE ui_layouts (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID REFERENCES auth.users(id) ON DELETE CASCADE NOT NULL,
  layout_config JSONB NOT NULL,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);


Таблица для 12 сфер жизни:
SQL
CREATE TABLE life_spheres (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID REFERENCES auth.users(id) ON DELETE CASCADE NOT NULL,
  sphere_name VARCHAR(255) NOT NULL,
  is_active BOOLEAN DEFAULT FALSE,
  health_percentage INT DEFAULT 0,
  resonance_degree FLOAT DEFAULT 0,
  -- Другие параметры, например, глобальная цель
  global_goal TEXT,
  -- Связь с категорией и маскотом
  category_mascot_url TEXT
);


Включите Row Level Security (RLS) для этих таблиц, чтобы пользователи могли получать доступ только к своим данным.
Шаг 6: Установка дополнительных зависимостей
Установите библиотеки для управления состоянием и Drag-and-Drop:
Bash
npm install zustand dnd-kit @dnd-kit/core @dnd-kit/sortable
npm install openai



Раздел 3: Создание базовой структуры интерфейса
Шаг 7: Разработка основного макета (/app/layout.tsx)
Создайте корневой макет, который будет определять общую структуру страницы: две боковые панели и центральная область контента.
Используйте CSS Flexbox или Grid для расположения этих трех основных блоков.
Шаг 8: Реализация зеркальных боковых панелей (<SidePanel />)
Создайте компонент components/SidePanel.tsx.
Панель должна быть зеркальной. Создайте
 props, такие как position="left" или position="right", чтобы управлять ее отображением.
Реализуйте логику сворачивания/разворачивания. В свернутом состоянии панель занимает 5% экрана, в развернутом — 15%.
Состояние "открыто/закрыто" для обеих панелей должно управляться глобально (через Zustand), чтобы другие компоненты могли на него реагировать.
Панель должна содержать слоты (children) для верхних кнопок, центрального блока (для сфер жизни) и нижних кнопок.
Шаг 9: Заполнение контента боковой панели
Верхний блок: Создайте блок для четырех иконок-кнопок, идущих в ряд, включая кнопку "плюс" для добавления новой программируемой кнопки. Под ними расположите блок для четырех категорий, идущих вниз ("способности", "навыки" и т.д.).
Центральный блок: Создайте список для отображения до 12 "сфер жизни". Начните с отображения первых 5 и кнопки "плюс" для добавления остальных.
Нижний блок: Добавьте три статичные кнопки и одну кнопку "плюс" для добавления новой.
Шаг 10: Создание контейнера для центральной панели (<MainContentArea />)
Создайте компонент components/MainContentArea.tsx.
Этот компонент должен занимать оставшееся пространство (70%) между двумя боковыми панелями.
Он будет служить "холстом" или "рабочим столом", который можно масштабировать колесиком мыши.
Внутри этого компонента будет логика переключения между двумя основными режимами: "Дашборд" и "Резонанс". 
Техническая документация для разработки платформы Arcanum (Часть 2 из 3)
Введение
В Части 1 была заложена основа проекта: настроена архитектура, подключены сервисы и создан базовый макет с боковыми панелями и центральной областью. Эта часть документации фокусируется на создании основного интерактивного пространства пользователя — "Режима Дашборда". Этот режим является стартовым экраном и представляет собой кастомизируемый виртуальный рабочий стол11.

Раздел 4: Реализация кастомизируемого рабочего стола
Это центральная панель, занимающая 75% экрана 2, которая функционирует как бесконечный холст, похожий на Miro3. Пользователь может масштабировать его и размещать на нем различные элементы4444.
Шаг 11: Создание компонента <WorkspaceCanvas />
Создайте основной компонент для этого вида: components/views/DashboardView.tsx.
Внутри него создайте компонент components/canvas/WorkspaceCanvas.tsx, который будет служить холстом.
Этот холст должен изначально центрироваться на главном фото-виджете при каждой загрузке платформы, чтобы обеспечить удобство пользователя5.
Шаг 12: Реализация масштабирования и панорамирования
Используя кастомные React хуки или библиотеку (например, react-zoom-pan-pinch), реализуйте следующий функционал для WorkspaceCanvas:
Масштабирование: Увеличение и уменьшение холста с помощью колесика мыши6.
Панорамирование: Перемещение по холсту с зажатой кнопкой мыши.
Состояние масштаба и положения холста (transform/matrix) должно храниться в локальном состоянии компонента.
Шаг 13: Внедрение Drag-and-Drop для виджетов с помощью dnd-kit
Оберните WorkspaceCanvas в DndContext для обеспечения функционала перетаскивания.
Создайте универсальный компонент-обертку <DraggableWidget />. Этот компонент будет принимать children и делать их перетаскиваемыми.
Реализуйте логику, позволяющую пользователю "бросать" на холст различные элементы, такие как изображения (включая PNG без фона)7.
Сохранение кастомизации: После каждого перемещения или изменения размера виджета, его новые координаты (x, y), размер (width, height) и z-index должны сохраняться в JSONB поле layout_config в таблице ui_layouts в Supabase. Это обеспечит персистентность уникального интерфейса каждого пользователя.

Раздел 5: Создание виджетов Дашборда
Дашборд состоит из нескольких ключевых виджетов, которые пользователь может настраивать.
Шаг 14: Компонент шапки с AI-генерируемым изображением (<HeaderImageWidget />)
Создайте компонент, который по умолчанию занимает верхнюю часть холста8.
Интеграция с ИИ:
Создайте API-endpoint (например, /api/generate-header-image).
Этот endpoint должен вызывать Personalization Orchestrator, который, в свою очередь, обращается к Image Generator Agent (например, DALL-E 3 через API OpenAI).
Промпт для генерации должен динамически создаваться на основе данных пользователя (навыки, достижения, текущие цели), полученных из Supabase9. Пример промпта: "Эпический цифровой арт, изображающий программиста и писателя, который играет на гитаре на вершине горы, в стиле киберпанк"10.
Сгенерированное изображение сохраняется (например, в Supabase Storage) и отображается в виджете.
Шаг 15: Колонка параметров пользователя (<StatsColumnWidget />)
Создайте виджет, который по умолчанию располагается слева на холсте и отображает ключевые параметры пользователя в виде столбца11.
Отображаемые параметры:
Актуальный уровень12.
Опыт до следующего уровня13.
Уровень энергии14.
Средний доход за час15.
Актуальная финансовая цель (например, 2000 франков в месяц)16.
Приоритетные задачи (высокий, средний, низкий приоритет)17.
Задачи в процессе выполнения18.
Активные "баффы" и "дебаффы" (например, "бодрость после ледяной ванны")19.
Таблица со здоровьем каждой из 12 сфер в процентах20. При нажатии на сферу должно появляться окно с расчетами: какая глобальная цель поставлена, что нужно сделать для получения +1% или +5% к прогрессу21.
Кастомизация: Добавьте кнопку "Добавить параметр", которая позволяет пользователю создавать и настраивать новые отслеживаемые метрики22. Эта конфигурация также сохраняется в
layout_config.

Раздел 6: Реализация диалогового окна с ИИ-клоном
Это окно является центром взаимодействия пользователя с ИИ-агентами платформы.
Шаг 16: Создание компонента <DialogueWindow />
Разработайте компонент components/DialogueWindow.tsx.
Внутри него будет отображаться аватар пользователя и имя его ИИ-клона (например, "MOYO")232323.
Шаг 17: Позиционирование и стилизация
Важно: Этот компонент не должен масштабироваться вместе с холстом WorkspaceCanvas24. Используйте
position: fixed или position: absolute для его размещения в нижней части MainContentArea.
Добавьте кнопку для сворачивания и разворачивания диалогового окна25. Состояние его видимости должно управляться глобально (Zustand).
Шаг 18: Отображение сообщений от ИИ-агентов
Компонент должен отображать историю диалога.
При загрузке он должен получить и показать приветственное сообщение от
 Task Assessor Agent, информирующее о времени до следующего обновления задач26.
Шаг 19: Реализация пользовательского ввода
Добавьте в нижнюю часть окна поле для текстового ввода27.
Реализуйте кнопку "плюс" для добавления файлов (PDF, видео) 28и кнопку "Инструменты"29.
При отправке сообщения, текст должен направляться на API-endpoint /api/chat, который передает запрос главному оркестратору Arcanum Brain. Arcanum Brain анализирует команду, делегирует ее нужному агенту (например, Button Programming Agent при запросе "добавь кнопку") и возвращает ответ для отображения в чате.

Конец Части 2.
В результате выполнения шагов из Части 2 у вас будет:
Функциональный и масштабируемый "рабочий стол" с возможностью перетаскивания и сохранения виджетов.
Реализованы ключевые виджеты: AI-генерируемая шапка и колонка с динамическими параметрами пользователя.
Создано не масштабируемое диалоговое окно для прямого взаимодействия с системой ИИ-агентов платформы.


Техническая документация для разработки платформы Arcanum (Часть 3 из 3)
Введение
В предыдущих частях были заложены архитектурный фундамент, настроен проект и реализован основной "Режим Дашборда". Эта заключительная часть документации посвящена созданию второго ключевого режима интерфейса — "Режима Резонанса", а также внедрению глобальных систем геймификации и подготовке проекта к финальному развертыванию.

Раздел 7: Реализация "Режима Резонанса" (<ResonanceView />)
Этот режим представляет собой визуализацию 12 сфер жизни и их взаимосвязей, занимая 90% основной панели и временно сворачивая боковые панели до 5%1.
Шаг 20: Логика переключения режимов
В глобальном хранилище состояний (Zustand) создайте переменную, отвечающую за активный режим центральной панели (activeView: 'dashboard' | 'resonance').
В компоненте MainContentArea реализуйте условный рендеринг, который будет отображать либо <DashboardView />, либо <ResonanceView /> в зависимости от значения этой переменной.
Добавьте кнопку в интерфейсе (например, на одной из боковых панелей) для переключения между этими режимами.
Шаг 21: Создание кругового расположения сфер
Создайте компонент components/views/ResonanceView.tsx.
Внутри него получите данные о 12 сферах жизни пользователя из Supabase.
Используя CSS, расположите 12 кнопок, представляющих сферы, по кругу2. Если сфера еще не активирована пользователем, на ее месте должна быть иконка "плюс" для добавления3.
Шаг 22: Визуализация связей и резонанса
Между иконками активных сфер необходимо динамически рисовать связи (линии, потоки частиц). Для этого можно использовать SVG или специализированные библиотеки, такие как react-flow или d3.
Внешний вид этих связей (толщина, цвет, скорость анимации) должен напрямую зависеть от параметра resonance_degree из таблицы life_spheres.
Важно: Эта визуализация должна автоматически обновляться в реальном времени каждый раз, когда пользователь вносит информацию о выполнении задания или любом другом прогрессе4. Это можно реализовать с помощью подписок на изменения в Supabase или через Webhooks.
Шаг 23: Отображение параметров сферы
Рядом с каждой кнопкой-сферой в круге должна отображаться небольшая панель5.
Эта панель выводит ключевые жизненные ресурсы сферы: "Здоровье сферы (%)" и "Степень резонанса с другими"6.

Раздел 8: Дерево Развития Сферы (<SphereDevelopmentTree />)
При нажатии на любую сферу (из боковой панели или из "Режима Резонанса") открывается огромное окно с деревом ее развития7.
Шаг 24: Реализация окна развития
Создайте компонент components/modals/SphereDevelopmentTree.tsx. Он должен открываться как полноэкранный модал или отдельная страница при клике на сферу.
Компонент принимает sphere_id в качестве props для загрузки соответствующей информации.
Шаг 25: Генерация структуры дерева и категорий
Внутри компонента отобразите название сферы и ее основные категории8. Например, для сферы "Здоровье" это могут быть "Нагрузка/Рост", "Восстановление" (питание, сон) и "Поддержание" (БАДы)9. Эта структура может быть предопределена в коде или храниться в отдельной таблице Supabase.
Шаг 26: AI-генерация маскотов для категорий
Под каждой категорией должен быть специальный блок с маскотом10.
Изначально этот блок может быть пустым, с кнопкой "Сгенерировать маскота".
При нажатии на кнопку отправляется запрос на API-endpoint (/api/generate-mascot), который вызывает Mascot Generator Agent.
Промпт для ИИ должен включать название категории и указание на общий стиль платформы (например, "Маскот для категории 'Исследование' в стиле платформы Arcanum. Это должен быть исследователь в белом халате с горящими энтузиазмом глазами")11.
URL сгенерированного изображения сохраняется в базе данных и отображается в интерфейсе12.

Раздел 9: Глобальные системы и геймификация
Шаг 27: Реализация "Режима Фокуса"
Добавьте в интерфейс кнопку, позволяющую сфокусировать всю энергию платформы на одной выбранной сфере13.
При нажатии на эту кнопку глобальное состояние current_focus_sphere обновляется.
Это действие вызывает
 Global Design Agent, который мгновенно изменяет дизайн всей платформы: цветовую палитру, стили, фоновые изображения, чтобы они соответствовали выбранной сфере (например, зеленые тона для финансов)14.
Действие логируется
 Arcanum Brain, который может накладывать ограничения на частоту смены фокуса (например, не чаще одного раза в неделю)15.
Шаг 28: События при получении нового уровня
Когда пользователь получает новый уровень, должна запускаться глобальная анимация16.
Это событие триггерит
 Global Design Agent, который на короткое время применяет по всей платформе "ультра-крутые" визуальные эффекты и частицы17171717.
Одновременно должен проигрываться звук, который пользователь может сам настроить (например, звук получения уровня из игры Arcanum)18.
Шаг 29: Система запланированных наград
Создайте в Supabase таблицу scheduled_rewards (user_id, trigger_level, reward_type, reward_content).
В настройках профиля дайте пользователю возможность запрограммировать награду за достижение определенного уровня (например, "при достижении 10 уровня показать мне это видеообращение к самому себе")19.
При срабатывании события "новый уровень" система должна проверять эту таблицу и, если есть совпадение, отображать пользователю запланированную награду.
Шаг 30: Интеграция финансовой системы
Создайте в настройках раздел, где пользователь может видеть свой актуальный баланс долларов для оплаты токенов OpenAI20. Это требует интеграции с API платежной системы.
При создании или принятии задачи (квеста) у пользователя должна быть опция "декларировать" или "поставить" определенную сумму на ее выполнение21. Эта информация передается
Punishment Agent, который управляет списаниями.

Раздел 10: Финализация и развертывание на Vercel
Шаг 31: Настройка переменных окружения
Перейдите в настройки вашего проекта на Vercel.
В разделе Settings > Environment Variables добавьте все секретные ключи:
NEXT_PUBLIC_SUPABASE_URL
NEXT_PUBLIC_SUPABASE_ANON_KEY
OPENAI_API_KEY
Другие ключи, используемые в проекте.
Шаг 32: Процесс развертывания
Убедитесь, что ваш проект находится в репозитории GitHub/GitLab/Bitbucket.
В Vercel импортируйте проект из вашего Git-провайдера.
Vercel автоматически определит, что это проект Next.js, и настроит процесс сборки.
После этого каждое изменение, отправленное в основную ветку (main или master), будет автоматически запускать новую сборку и развертывание проекта.
Шаг 33: Оптимизация и тестирование
Перед запуском проведите полное тестирование всех пользовательских сценариев, особенно кастомизации интерфейса и взаимодействия с ИИ-агентами.
Убедитесь, что все политики безопасности строк (RLS) в Supabase настроены корректно, чтобы пользователи не могли получить доступ к чужим данным.
Проверьте производительность, особенно рендеринг визуализаций в "Режиме Резонанса".

Конец Части 3.


